# ==== Vue.js 基础 ====

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'></div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    template: '...',
    data: {},
    filters: {},
    methods: {},
    computed: {},
    watch: {},
    components: {
        'component-a': {
            template: "...",
            data: function(){ return {...} },
            props: [], // {}
            methods: {},
            components: {},
            //...
        }
    },

    //生命周期钩子
    beforeCreate: function(){},
    created: function(){},
    beforeMount: function(){},
    mounted: function(){},
    beforeUpdate: function(){},
    updated: function(){},
    activated: function(){},
    deactivated: function(){},
    beforeDestroy: function(){},
    destroyed: function(){},
    errorCaptured: function(){},
        
    mixins: [],
    extends: {},
    directives: {},

})
</script>
```



# 简介

- 前端三大新框架: `Angular.js`   `React.js`   `Vue.js`
- Vue可以作为一个js库来使用
- Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统。
- 提高开发效率的发展历程：原生JS -> Jquery之类的类库 -> 前端模板引擎 -> Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）
- Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别
   + MVC 是后端的分层开发概念；
   + MVVM 是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VueModel
      + Model: 数据层.  可能是写死的数据,  或通过网络请求从服务器获取的数据
      + View: 视图层.  通常就是 DOM 层,  给用户展示数据
      + ViewModel: 视图模型层.  View 和 Model 沟通的桥梁.  一方面实现 **数据绑定**, 将 Model 的改变实时反应到 View 中;  另一方面实现 **DOM 监听**,  当 DOM 发生一系列事件 (点击/滚动/触摸) 时, 可以监听到并在需要时改变对应的数据

PS 编程范式:

- 命令式编程:  JS
- 声明式编程:  Vue



# 资源

- Vue Docs 中文文档翻译合集
  - 这里会放置所有 Vue 官方维护的库的中文文档的链接，以及官方未提供多语言支持的库文档的中文翻译 (通常这样的库都比较小或不够稳定，故集中放这里)。
- Vue.js使用文档   
  - 官方文档:  https://cn.vuejs.org/v2/guide/
  - 官方 API 文档:  https://cn.vuejs.org/v2/api/ 
  - 梁兴华 Vue 全家桶:   http://doc.liangxinghua.com/vue-family/1.html 

- Vue.js库下载    [https://cn.vuejs.org/v2/guide/installation.html](https://cn.vuejs.org/v2/guide/installation.html)

```
开发版本	开发中可以使用开发版本vue.js
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

生产版本	产品上线要换成vue.min.js
```



# 基本概念

- 用 `<script>` 标签引入，`Vue` 会被注册为一个全局变量

- vue.js中没有ready方法, 直接把代码放到body标签内的末尾

- vue插件下载: 如代码提示功能,  在vscode商店搜索vue

Vue基本语法

```html
<body>
    <div id="app">
        <p>{{ msg }}</p>
        <input type="button" value="改变值" @click="fnChange">
        <input type="button" value="改变值" @click="fnChange1">
    </div>
    <script>
        // 一个应用是从一个 Vue 的对象开始
        // Vue对象接管 div 标签
        var vm = new Vue({
            el: '#app',   // 控制范围 (接管的大标签)
            data:{
                msg:'hello world'
            },
            // 给Vue对象添加方法
            methods:{
                // NO.1
                fnChange:function(){
                    this.msg += ' hah';
                },
                // NO.2
                fnChange1(){
                    this.msg += ' heh';
                }
            }
        })
    </script>
</body>
```



# 模板语法

```html
<body>
    <div id="app">

        <!-- 添加文本, 使用“Mustache”语法 (双大括号)  -->
        <p>{{ str }}</p>
        
        <!-- 添加事件, v-on 或 @ -->
        <input type="button" value="字符串反转" @click="fn_reverse">
        <p>{{ num }}</p>
        <input type="button" value="数值增加" @click="fn_add">

        <!-- 三元运算符 -->
        <p>{{ is_ok?'yes':'no' }}</p>
        <input type="button" value="改变布尔值" v-on:click="fn_change">   <br><br>

        <!-- 添加属性, 需要加一个 v-bind 指令 或 冒号 : -->
        <a v-bind:href="url">跳转到百度</a>
        
        <!-- 在点击事件中用赋值语句 切换元素内容 -->
        <img v-bind:src="img" alt="图片">
        <input type="button" value="切换图片" @click="img='images/bg.png'">
    </div>
    
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                str: 'ABCDEFG',
                num: 100,
                is_ok: false,
                url: 'http://www.baidu.com',
                img: 'images/bgc.png'    
            },
            methods: {
                fn_reverse: function(){
                    // 字符串反转
                    this.str = this.str.split('').reverse().join('');
                },
                fn_add: function(){
                    this.num += 10;
                },
                fn_change: function(){
                    if (this.is_ok==true){
                        this.is_ok = false;
                    }
                    else{
                        this.is_ok = true;
                    }
                }
            }
        })
    </script>
</body>
```



## 插值 

### 文本 

​	数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值,  无论何时，绑定的数据对象上 `msg` 属性发生了改变，插值处的内容都会更新。  

```html
<span>Message: {{ msg }}</span>
```

> 使用 **v-once** 指令,  执行一次性地插值，当数据改变时，插值处的内容不会更新
>
> ```html
> <span v-once>This will never change: {{ msg }}</span>
> ```

### v-text

{{xxx}}取值有个弊端，当网速很慢或 javascript 出错时，会在页面显示 {{xxx}}，Vue 提供的 v-text 可以解决这个问题

```html
<div>{{ message }}</div>
<!-- 和下面的一样 -->
<div v-text="message"></div>
```

### v-html

双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 `v-html` 指令： 

```html
<div v-html="rawHtml"></div>
```

被插入的内容都会被当做 HTML —— 数据绑定会被忽略。注意，你不能使用 `v-html` 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。组件更适合担任 UI 重用与复合的基本单元。 

​	你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容插值。 

### 标签属性 

Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令： 

```html
<div v-bind:id="dynamicId"></div>

<!-- 这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除 -->
<button v-bind:disabled="someDynamicCondition">Button</button>
```

### 使用 JS 表达式 

​	迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持。

```html
{{ number + 1 }}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
<div v-bind:id="'list-' + id"></div>
```

这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。 

```html
<!-- 这是语句，不是表达式 -->
{{ var a = 1 }}
<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 `Math` 和 `Date` 。你不应该在模板表达式中试图访问用户定义的全局变量。



### 过滤器 

- Vue.js允许自定义过滤器，可被用于一些常见的文本格式化;

- 过滤器可以用在两个地方： `双花括号插值`  和  `v-bind 表达式`,  均由“管道符”指示

```html
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在v-bind中 -->
<div v-bind:id="rawId | formatId"></div>
```

过滤器实际上是一个函数，可以在一个组件的选项中定义组件内部过滤器 ,  只能在定义它的对象接管标签内使用

```javascript
var vm = new Vue({
    // ...
    filters: {
        capitalize: function (value) {  // 过滤器函数总接受表达式的值作为第一个参数
            if (!value) {
                return '';
            } else {
                value = value.toString();
                return value.charAt(0).toUpperCase() + value.slice(1);
            }
        }
    }
})
```

也可以在创建 Vue 实例之前全局定义过滤器,  可以全局使用

```javascript
Vue.filter('capitalize',function(value){
    if (!value) {
        return '';
    } else {
        value = value.toString();
        return value.charAt(0).toUpperCase() + value.slice(1);
    }
});
```

过滤器可以串联： 

```
{{ message | filterA | filterB }}
```

过滤器是 JavaScript 函数，因此可以接受参数： 

```
{{ message | filterA('arg1', arg2) }}
```

这里，字符串 `'arg1'` 将传给过滤器作为第二个参数， `arg2` 表达式的值将被求值然后传给过滤器作为第三个参数。 



#### 自定义一个日期格式化过滤器

1. HTML元素：

```
<td> {{item.ctime | dateFormat('yyyy-mm-dd')}} </td>
```

2. 私有 `filters` 定义：

```javascript
filters: {  // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用
    dateFormat(input, pattern = "") { // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错
      var dt = new Date(input);
      
      // 获取年月日
      var y = dt.getFullYear();
      var m = (dt.getMonth() + 1).toString().padStart(2, '0');
      var d = dt.getDate().toString().padStart(2, '0');

      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日
      // 否则，就返回  年-月-日 时：分：秒
      if (pattern.toLowerCase() === 'yyyy-mm-dd') {
        return `${y}-${m}-${d}`;
      } else {
        
        // 获取时分秒
        var hh = dt.getHours().toString().padStart(2, '0');
        var mm = dt.getMinutes().toString().padStart(2, '0');
        var ss = dt.getSeconds().toString().padStart(2, '0');

        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
      }
    }
  }
```

> 使用 ES6 中的字符串新方法 `String.prototype.padStart(maxLength, fillString='')` 或 `String.prototype.padEnd(maxLength, fillString='')` 来填充字符串；







### v-pre、v-cloak、v-once

（1）v-pre
在模板中跳过vue的编译，直接输出原始值，如果在标签中加入v-pre就不会输出vue中的data值了

```javascript
<div v-pre>{{message}}</div>
```

（2）v-cloak
在vue渲染完指定的整个DOM后才进行显示。它必须和CSS样式一起使用

```javascript
// css
[v-cloak] {
    display: none;
}

// html
<div v-cloak>{{message}}</div>
```

（3）v-once
只显示DOM第一次渲染的值，以后不改变了

```javascript
<div v-once>第一次绑定的值：{{message}}</div>
```



## 指令 

​	指令（Directives）是带有 `v-` 前缀的特殊属性。指令属性的值预期是**单一 JavaScript 表达式**（除了 `v-for`，之后再讨论）。指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上。

```html
<!-- v-if  根据表达式值的真假来移除/插入元素 -->
<p v-if="seen">Now you see me</p>
```

### 参数 

​	一些指令能接受一个“参数”，在指令后以冒号指明。

```html
<!-- v-bind  用来响应地更新 HTML 属性 -->
<!-- 这里 href 是参数，告知 v-bind 将该元素的 href 属性与表达式 url 的值绑定 -->
<a v-bind:href="url"></a>

<!-- v-on  用于监听 DOM 事件 -->
<a v-on:click="doSomething">
```

### 修饰符 

​	修饰符（Modifiers）是以半角句号 `.` 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`： 

```
<form v-on:submit.prevent="onSubmit"></form>
```

之后当我们更深入地了解 `v-on` 与 `v-model`时，会看到更多修饰符的使用。 



### 自定义指令

1. 自定义全局和局部指令

```javascript
    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：
    Vue.directive('focus', {
      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用
        el.focus();
      }
    });

    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：
      directives: {
        color: { // 为元素设置指定的字体颜色
          bind(el, binding) {
            el.style.color = binding.value;
          }
        },
        'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数
          el.style.fontWeight = binding2.value;
        }
      }
```

2. 使用自定义指令

```
<input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900">
```





## 缩写 

Vue.js 为两个最为常用的指令提供了特别的缩写： 

```html
<!-- v-bind 缩写 -->
<!-- <a v-bind:href="url"></a> -->
<a :href="url"></a>

<!-- v-on 缩写 -->
<!-- <a v-on:click="doSomething"></a> -->
<a @click="doSomething"></a>
```

`:` 与 `@` 对于属性名来说都是合法字符，在所有支持 Vue.js 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记。







# 列表渲染

## v-for

`v-for` 指令根据一组数组的选项列表进行渲染

```html
<html>
<body>
<div id='app'>
    <ul>
        <!-- <li v-for='item in items'>{{ item.username }} - {{ item.age }}</li> -->
        <!-- <li v-for='item of items'>{{ item.username }} - {{ item.age }}</li> -->
        <li v-for='(item,index) in items'>{{ index+1 }} - {{ item.username }} - {{ item.age }}</li>
    </ul>
</div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        items: [
            {'username': '吴邪', 'age': 18},
            {'username': '张起灵', 'age': 180},
        ]
    },
    methods: {},
})
</script>
```



## Template v-for 

如同 `v-if` 模板，也可以用带有 `v-for` 的 `<template>` 标签来渲染多个元素块

```html 
<ul>
    <ul>
        <template v-for='(item,index) in items'>
        <li>{{ index+1 }} - {{ item.username }} - {{ item.age }}</li>
        <li class="divider"></li>
        </template>
    </ul>
</ul>
```



## 对象迭代 v-for 

可以用 `v-for` 通过一个对象的属性来迭代。 

> 在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。 

```html
<html>
<body>
<div id='app'>
    <ul>
        <!-- <li v-for='value in obj'>{{ value }}</li> -->
        <!-- <li v-for='value of obj'>{{ value }}</li> -->
        <!-- <li v-for='(value,key) in obj'>{{ key }} - {{ value }}</li> -->
        <li v-for='(value,key,index) in obj'>{{ index+1 }} - {{ key }} - {{ value }}</li>
    </ul>
</div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        obj: {username: '王胖子', age: 20}
    },
    methods: {},
})
</script>
```



## 整数迭代 v-for 

`v-for` 也可以操作一个整数。在这种情况下，它将重复多次模板。 

>  注:  v-for 操作整数是从 1 开始

```html
<html>
<body>
<div id='app'>
    <ul>
        <!-- <li v-for='num in 5'>整数迭代</li> -->
        <li v-for='(num,index) in 5'>整数迭代, 索引:{{ index }}, 数字:{{ num }}</li>
    </ul>
</div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {},
    methods: {},
})
</script>
```



## v-for 与 v-if 组合

>  注意我们**不**推荐在同一元素上使用 `v-if` 和 `v-for`。更多细节可查阅[风格指南](https://cn.vuejs.org/v2/style-guide/#避免-v-if-和-v-for-用在一起-必要)。 

当它们处于同一节点，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中。当你只想为*部分*项渲染节点时，这种优先级的机制会十分有用，如下：

```html
<!-- 只渲染未完成的 todo -->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo }}
</li>
```

而如果你的目的是有条件地跳过循环的执行，那么可以将 `v-if` 置于外层元素 (或`<template>`) 上。如：

```html
<ul v-if="todos.length">
  <li v-for="todo in todos">
    {{ todo }}
  </li>
</ul>
<p v-else>No todos left!</p>
```



## 组件 和 v-for

看官方文档:   [https://cn.vuejs.org/v2/guide/list.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-v-for](https://cn.vuejs.org/v2/guide/list.html#在组件上使用-v-for) 



## key

 https://cn.vuejs.org/v2/api/#key 

> 2.2.0+ 的版本里，**当在组件中使用** v-for 时，key 现在是必须的。
>
> 有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。 

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` 属性。理想的 `key` 值是每项都有唯一 id。

因为它是 Vue 识别节点的一个通用机制， `key` 并不特别与 `v-for` 关联，key 还具有其他用途 (另查)

```html
<html>
<body>
<div id='app'>
    <ul>
        <!-- <li v-for='item in items' v-bind:key='item.id'>{{ item.name }}</li> -->
        <li v-for='item in items' :key='item.id'>{{ item.name }}</li>
    </ul>
</div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        items: [
            {'id': 1, 'name': 'Martin'},
            {'id': 2, 'name': 'John'},
            {'id': 3, 'name': 'Jerry'},
            {'id': 4, 'name': 'Tony'},
        ]
    },
    methods: {},
})
</script>
```



## 数组更新检测

变异方法

> Vue 包含一组观察数组的变异方法，会改变被这些方法调用的原始数组,  所以它们也会触发视图更新。

- `push()` 
- `pop()` 	
- `shift()` 	
- `unshift()` 	
- `splice()` 	
- `sort()` 	
- `reverse()` 

重塑数组

> 非变异方法

-  `filter()``
- ``concat()`
- `slice()`

这些非变异方法不会改变原始数组，但总是返回一个新数组。当使用用非变异方法时，可以用新数组替换旧数组： 

```javascript
vm.items = vm.items.filter(function (item) {
	return item.message.match(/Foo/)
})
```

注意事项

> 由于 JavaScript 的限制， Vue 不能检测以下变动的数组： 
>
> 1. 当你直接设置一个项的索引时，例如： `vm.items[index] = newValue`
> 2. 当你修改数组的长度时，例如： `vm.items.length = newLength`
>
> ```javascript
> var vm = new Vue({
>   data: {
>     items: ['a', 'b', 'c']
>   }
> })
> vm.items[1] = 'x' // 不是响应性的
> vm.items.length = 2 // 不是响应性的
> ```
>
> 为了避免第一种情况，以下两种方式将达到像 `vm.items[index] = newValue` 的效果， 同时也将触发状态更新： 
>
> ```javascript
> // Vue.set
> Vue.set(vm.items, index, newValue)
> // 也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名
> vm.$set(vm.items, indexOfItem, newValue)
> 
> // Array.prototype.splice
> vm.items.splice(index, 1, newValue)
> ```
>
> 避免第二种情况，使用 `splice`： 
>
> ```javascript
> vm.items.splice(newLength)
> ```



## 对象变更检测注意事项

还是由于 JavaScript 的限制，**Vue 不能检测对象属性的添加或删除**：

```javascript
var vm = new Vue({
  data: {
    a: 1
  }
})
// `vm.a` 现在是响应式的

vm.b = 2
// `vm.b` 不是响应式的
```

 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式属性。例如 

```javascript
var vm = new Vue({
  data: {
    userProfile: {
      name: 'Anika'
    }
  }
})

// 为已有对象赋值单个新响应式属性
Vue.set(vm.userProfile, 'age', 27)
// or
vm.$set(vm.userProfile, 'age', 27)

// 为已有对象赋值多个新响应式属性
vm.userProfile = Object.assign({}, vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
```





## 显示过滤/排序结果 

​	有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。 

```html
<html>
<body>
<div id='app'>
    <ul>
        <li v-for='(num,index) in evenNumbers'>{{ index }} - {{ num }}</li>
    </ul>
</div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        numbers: [ 1, 2, 3, 4, 5 ]
    },
    methods: {},
    computed: {
        evenNumbers: function(){
            var result = this.numbers.filter(function(num){
                return num % 2 === 0;
            })
            return result;
        }
    },
})
</script>
```

>  在计算属性不适用的情况下 (例如，在嵌套 `v-for` 循环中) 你可以使用一个方法： 
>
> ```html
> <li v-for="n in even(numbers)">{{ n }}</li>
> 
> 
> data: {
>   numbers: [ 1, 2, 3, 4, 5 ]
> },
> methods: {
>   even: function (numbers) {
>     return numbers.filter(function (number) {
>       return number % 2 === 0
>     })
>   }
> }
> ```

# 计算属性

在模板中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模板中放入太多的逻辑会让模板过重且难以维护。例如： 

```html
<div id="example">
{{ message.split('').reverse().join('') }}
</div>
```

在这种情况下，模板不再简单和清晰。任何复杂逻辑，都应当使用**计算属性**。 

> 在以下例子中,  可以打开浏览器的控制台，修改 vm.message 的值 。 `vm.reversedMessage` 的值始终取决于 `vm.message` 的值。 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
<div id='app'>
    <p>原字符串: {{ str }}</p>
    <p>反转后的字符串: {{ reversedStr }}</p>
</div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        str: 'abcd1234',
    },
    methods: {},
    computed: {
        reversedStr: function(){
            return this.str.split('').reverse().join('');
        }
    },
})
</script>
```

## computed 与 methods  比较

不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。对于最终的结果，两种方式确实是相同的。然而，不同的是**计算属性是基于它的依赖缓存**。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 `message` 没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。 

​	这也同样意味着如下计算属性将不会更新，因为 `Date.now()` 不是响应式依赖： 

```
computed: {
    now: function () {
    	return Date.now()
    }
}
```

为什么需要缓存？

假设我们有一个重要的计算属性 **A** ，这个计算属性需要一个巨大的数组遍历和做大量的计算。然后我们可能有其他的计算属性依赖于 **A** 。如果没有缓存，我们将不可避免的多次执行 **A** 的 getter ！

如果你不希望有缓存，请用 method 替代。 



## computed 与 watch 比较

Vue.js 提供了一个方法 `$watch` ，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， `$watch` 很诱人 —— 特别是如果你来自 AngularJS 。不过，通常更好的办法是使用计算属性而不是一个命令式的 `$watch` 回调。思考下面例子： 

1. 使用侦听属性 watch

   ```html
   <html>
   <head>
       <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
   </head>
   <body>
   <div id='app'>
       <p>{{ fullName }}</p>
   </div>
   </body>
   </html>
   <script>
   var vm = new Vue({
       el: '#app',
       data: {
           firstName: 'Foo',
           lastName: 'Bar',
           fullName: 'Foo Bar',
       },
       methods: {},
       watch: {  //监听属性, 在目标属性的值发生变化时触发执行
           firstName: function(val){
               this.fullName = val + ' ' + this.lastName;
           },
           lastName: function(val){
               this.fullName = this.firstName + ' ' + val;
           }
       }
   })
   </script>
   ```

2. 使用计算属性 computed  (更好)

   ```html
   <html>
   <head>
       <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
   </head>
   <body>
   <div id='app'>
       <p>{{ fullName }}</p>
   </div>
   </body>
   </html>
   <script>
   var vm = new Vue({
       el: '#app',
       data: {
           firstName: 'Foo',
           lastName: 'Bar',
           //fullName: 'Foo Bar',  //计算属性中已定义 fullName, 此处应注释掉
       },
       methods: {},
       computed: {  //计算属性
           fullName: function(){
               return this.firstName + ' ' + this.lastName;
           }
       },
   })
   </script>
   ```



## 计算属性的 getter / setter

计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ： 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
<div id='app'>
    <p>{{ fullName }}</p>
</div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        firstName: 'Foo',
        lastName: 'Bar',
    },
    methods: {},
    // computed: {  //计算属性, 默认只有 getter
    //     fullName: function(){
    //         return this.firstName + ' ' + this.lastName;
    //     }
    // },
    computed: {
        fullName: {
            get: function(){
                return this.firstName + ' ' + this.lastName;
            },
            set: function(newFullName){  // 在 vm.fullName = 'Martin Leo' 时被调用
                var names = newFullName.split(' ');
                this.firstName = names[0];
                this.lastName = names[names.length - 1];
            }
        }
    },
})
</script>
```



# 侦听属性

虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher 。当你想要在数据变化响应时，执行异步操作或昂贵操作时，这是很有用的。 

侦听属性:

- 侦听属性的作用是侦听某属性值的变化，从而做相应的操作;

- 侦听属性是一个对象，它的键是要监听的对象或者变量，值一般是函数;

- 当被侦听的元素发生变化时，需要执行的函数传入两个形参，第一个是当前值，第二个是变化后的值.

例如： 

> 在这个示例中，使用 `watch` 选项允许我们执行异步操作（访问一个 API），限制我们执行该操作的频率，并直到我们得到最终结果时，才设置中间状态。这是计算属性无法做到的。 
>
> ​	除了 `watch` 选项之外，还可以使用 vm.$watch API 命令。 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
    <script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
</head>
<body>
<div id='app'>
    <p>Ask a yes/no question: <input v-model="question"></p>
    <p>{{ answer }}</p>
</div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        question: '',
        answer: 'I cannot give you an answer until you ask a question!'
    },
    methods: {},
    watch: {
        // 如果 question 发生改变，这个函数就会运行
        question: function(newQuestion, oldQuestion) {
            this.answer = 'Waiting for you to stop typing...'
            this.getAnswer()
        }
    },

    methods: {
        // _.debounce 是一个通过 lodash 限制操作频率的函数。
        // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率,
        // ajax请求直到用户输入完毕才会发出.
        // 学习更多关于 _.debounce function (and its cousin _.throttle), 参考: https://lodash.com/docs#debounce
        getAnswer: _.debounce(function(){

            var vm = this

            if (this.question.indexOf('?') === -1) {
                vm.answer = 'Questions usually contain a question mark. ;-)'
                return
            }
            vm.answer = 'Thinking...'

            // 异步发送请求
            axios.get('https://yesno.wtf/api')
            .then(function(response){
                vm.answer = _.capitalize(response.data.answer)
            })
            .catch(function(error){
                vm.answer = 'Error! Could not reach the API. ' + error
            })
        },
        // 这是为用户停止输入等待的毫秒数
        500)
    }
})
</script>
```



# Class 与 Style 绑定

## 绑定class

```html
</head>
	...
	<style>
    .big {
        font-size: 30px;
    }
    .red {
        color: red;
    }
    .sty{
        font-style: oblique;
    }
    </style>
</head>
<body>
    <div class="app">
        <!-- 传一个 数组 -->
        <p :class="['big', 'sty']">第 1 个段落</p>
        
        <!-- 包含一个 三元表达式 -->
        <p v-bind:class="[is_big?'big':'',  'red']">第 2 个段落</p>
        
        <!-- 传一个 对象, 对象的属性是 类名, 属性名和属性值 可以不加双引号 -->
        <p :class="{red: 'is_red', sty: 'is_sty'}">第 3 个段落</p>

        <!-- 传一个对象的引用, 注意 实际obj 中的属性值 必须加引号 -->
        <p :class="obj">第 4 个段落</p>
    </div>
    <script>
        new Vue({
            el: '.app',
            data: {
                is_big: true,
                is_red: true,
                is_sty: true,
                obj: {red: 'is_red', sty: 'is_sty'}
            },
            methods: {}
        });
    </script>
</body>
```



### 对象语法 

我们可以传给 `v-bind:class` 一个对象，以动态地切换 class 。 

```html
<!-- 下面 class myCls 的更新将取决于数据属性 isActive 是否为真值 -->
<!-- <div v-bind:class="{ myCls: isActive }"></div> -->
<div :class="{ myCls: isActive }"></div>

<!-- v-bind:class 指令可以与普通的 class 属性共存 -->
<div class="static" :class="{ myCls: isActive, 'text-danger': hasError }">
</div>
```

v-bind:class 指令可以与普通的 class 属性共存

```html
<html>
<body>
    <div class='app'>
        <!-- v-bind:class 指令可以与普通的 class 属性共存 -->
        <div class="static" :class="{ myCls: isActive, 'text-danger': hasError }"></div>

        <!-- 渲染后的 class 结果： -->
        <div class="static myCls"></div>
        <!-- 如果 hasError 的值为 true ， class列表将变为 "static active text-danger" -->
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '.app',
    data: {
        isActive: true,
        hasError: false,
    }
})
</script>
```

也可以直接绑定数据里的一个对象

```html
<html>
<body>
    <div class='app'>
        <div class="static" :class="clsObj"></div>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '.app',
    data: {
        clsObj: { myCls: true, 'text-danger': true },
    },
})
</script>
```

也可以在这里绑定返回对象的计算属性。这是一个常用且强大的模式： 

```html
<html>
<body>
    <div class='app'>
        <div class="static" :class="clsObj"></div>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '.app',
    data: {
        isActive: true,
        error: null
    },
    computed: {
        clsObj: function(){
            return {
                active: this.isActive && !this.error,
                'text-danger': this.error && this.error.type === 'fatal',
            }
        }
    }

})
</script>
```



### 数组语法 

可以把一个数组传给 `v-bind:class` ，以应用一个 class 列表： 

```html
<html>
<body>
    <div class='app'>
        <div class="static" :class="[activeClass, errorClass]"></div>
        <!-- 渲染为: -->
        <div class="static active text-danger"></div>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '.app',
    data: {
        activeClass: 'active',
        errorClass: 'text-danger'
    },
    computed: {}
})
</script>
```

如果你也想根据条件切换列表中的 class ，可以用三元表达式： 

```html
<div v-bind:class="[isActive ? activeClass : '', errorClass]">
```

可以在数组语法中使用对象语法： 

```html
<div v-bind:class="[{ active: isActive }, errorClass]">
```



## 绑定style

```html
<body>
    <div id="app">
        <!-- vue中的样式 style -->
        <p :style="{'color': 'white', 'background-color': 'lightblue'}">vue中的 style</p>
        <p :style="[style_obj_01, style_obj_02]">vue中的 style</p>
    </div>
    <script>
        new Vue({
            el: '#app',
            data: {
                style_obj_01: {'color': 'blue'},
                style_obj_02: {'background-color': 'lightgreen'}
            }
        })
    </script>
</body>
```

### 对象语法 

`v-bind:style` 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）.  

```html
<html>
<head>
</head>
<body>
    <div class='app'>
        <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }">
            这是一个div
        </div>
    </div>
</body>
<script>
    var vm = new Vue({
        el: '.app',
        data: {
            activeColor: 'red',
            fontSize: 30
        }
    })
</script>
</html>
```

直接绑定到一个样式对象通常更好，让模板更清晰： 

```html
<div v-bind:style="styleObject"></div>
...
    data: {
        styleObject: {
            color: 'red',
            fontSize: '13px'
        }
    }
```

同样的，对象语法常常结合返回对象的计算属性使用



### 数组语法 

`v-bind:style` 的数组语法可以将多个样式对象应用到一个元素上： 

```html
<div v-bind:style="[baseStyles, overridingStyles]">
```



### 自动添加前缀 

当 `v-bind:style` 使用需要特定前缀的 CSS 属性时，如 `transform` ，Vue.js 会自动侦测并添加相应的前缀。 

### 多重值

> 2.3.0+

从 2.3.0 起你可以为 `style` 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：

```html
<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
```

这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 `display: flex`。



# 表单控件绑定

## v-model

用 `v-model` 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 `v-model` 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。 

```html
表单控件进行数据绑定时的语法 `<input v-model="something">` 仅仅是一个语法糖:
<input v-bind:value="something" v-on:input="something = $event.target.value"> 
```

 `v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 `data` 选项中声明初始值,   但 `v-model` 并不关心表单控件初始化所生成的值。因为它会选择 Vue 实例数据来作为具体的值。 



`v-model` 在内部为不同的输入元素使用不同的属性并抛出不同的事件：

- text 和 textarea 元素使用 `value` 属性和 `input` 事件；
- checkbox 和 radio 使用 `checked` 属性和 `change` 事件；
- select 字段将 `value` 作为 prop 并将 `change` 作为事件。



## 基础用法 

### 文本 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <form action="#">
            <input type="text" v-model="username" name="username" id="">
            <!-- 使用 username. 根据表单输入的内容实时更新 -->
            <p>输入用户名是: {{ username }}</p>
        </form>

    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        username: "",  // 初始化 username 的值
    },
})
</script>
```

### 多行文本 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <form action="#">
            <span>输入的多行文本内容是:</span>
            <p style="white-space: pre">{{ text }}</p>
            <textarea v-model="text" placeholder="add multiple lines"></textarea>
        </form>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        text: "",
    },
})
</script>
```

### 复选框  - 单选

单个勾选框，绑定逻辑值(true/false)： 

```html
<input type="checkbox" id="checkbox" v-model="checked">
<label for="checkbox">{{ checked }}</label>
```

### 复选框  - 多选

多个勾选框，绑定到同一个数组： 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <form action="#">
            <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
            <label for="jack">Jack</label>
            
            <input type="checkbox" id="john" value="John" v-model="checkedNames">
            <label for="john">John</label>
            
            <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
            <label for="mike">Mike</label><br>
            
            <span>Checked names: {{ checkedNames }}</span>
        </form>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        checkedNames: [],
    },
})
</script>
```



### 单选按钮 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <form action="#">
            <input type="radio" id="one" value="One" v-model="picked">
            <label for="one">One</label>
            <br>
            <input type="radio" id="two" value="Two" v-model="picked">
            <label for="two">Two</label>
            <br>

            <span>Picked: {{ picked }}</span>
        </form>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        picked: "",
    },
})
</script>
```



### 选择列表  - 单选列表

单选列表

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <form action="#">
            <select v-model="selected">
                <option>A</option>
                <option>B</option>
                <option>C</option>
            </select>

            <span>Selected: {{ selected }}</span>
        </form>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        selected: "",
    },
})
</script>
```

### 选择列表  - 多选列表

多选列表（绑定到一个数组）： 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <form action="#">
            <select v-model="selected" multiple>
                <option>A</option>
                <option>B</option>
                <option>C</option>
            </select>

            <span>Selected: {{ selected }}</span>
        </form>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        selected: [],
    },
})
</script>
```



### 选择列表 - 动态选项

动态选项，用 `v-for` 渲染： 

> 以多选列表为例

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <form action="#">
            <select v-model="selected" multiple>
                <option v-for='opt in options' v-bind:value='opt.value'>
                    {{ opt.text }}
                </option>
            </select>

            <span>Selected: {{ selected }}</span>
        </form>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        options: [
            {text: 'One', 'value': 'A'},
            {text: 'Two', 'value': 'B'},
            {text: 'Three', 'value': 'C'},
        ],
        selected: ['A', 'C'],  //提供默认选项
    },
})
</script>
```





## 绑定 value 

对于单选按钮，勾选框及选择列表选项， `v-model` 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <form action="#">
            <!-- 当选中时，`picked` 为字符串 "a" -->
            <input type="radio" v-model="picked" value="a">
            <input type="radio" v-model="picked" value="b"><br/>
            
            <!-- `toggle` 为 true 或 false -->
            <input type="checkbox" v-model="toggle"><br/>
            
            <!-- 当选中A时，`selected` 为字符串 "a" -->
            <select v-model="selected">
                <option value="a">A</option>
                <option value="b">B</option>
            </select>

            <p>picked: {{ picked }}</p>
            <p>toggle: {{ toggle }}</p>
            <p>selected: {{ selected }}</p>
        </form>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        picked: "",
        toggle: false,
        selected: "",
    },
})
</script>
```

但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 `v-bind` 实现，并且这个属性的值可以不是字符串。 

### 复选框 

```html
<input type="checkbox" v-model="toggle"
            v-bind:true-value="a"
            v-bind:false-value="b">

// 当选中时
vm.toggle === vm.a
// 当没有选中时
vm.toggle === vm.b
```

### 单选按钮 

```html
<input type="radio" v-model="pick" v-bind:value="a">

// 当选中时
vm.pick === vm.a
```

### 选择列表设置 

```html
<select v-model="selected">
    <!-- 内联对象字面量 -->
	<option v-bind:value="{ number: 123 }">123</option>
</select>

// 当选中时
typeof vm.selected  // -> 'object'
vm.selected.number  // -> 123
```



## 修饰符 

### `.lazy` 

在默认情况下， `v-model` 在 `input` 事件中同步输入框的值与数据，但你可以添加一个修饰符 `lazy` ，从而转变为在 `change` 事件中同步： 

```html
<!-- 在 "change" 而不是 "input" 事件中更新 -->
<input v-model.lazy="msg" >
```

### `.number` 

如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 `number` 给 `v-model` 来处理输入值： 

> 这通常很有用，因为在 `type="number"` 时 HTML 中输入的值也总是会返回字符串类型。 

```html
<input v-model.number="age" type="number">
```

### `.trim` 

如果要自动过滤用户输入的首尾空格，可以添加 `trim` 修饰符到 `v-model` 上过滤输入： 

```html
<input v-model.trim="msg">
```



# 事件处理器

## 监听事件  v-on

可以用 `v-on` 指令监听 DOM 事件来触发一些 JavaScript 代码。 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <p>counter: {{ counter }}</p>
        <button v-on:click="counter++">加 1</button>
        <button v-on:click="counter = 0">清 0</button>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        counter: 0,
    },
})
</script>
```



## 事件处理方法

许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在 `v-on` 指令中是不可行的。因此 `v-on` 可以接收一个定义的方法来调用。 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <p>counter: {{ counter }}</p>
        <button v-on:click="minusOne">减 1</button>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        counter: 0,
    },
    methods: {
        minusOne: function(event){
            // `this` 在方法里指当前 Vue 实例
            this.counter--;
            // `event` 是原生 DOM 事件
            console.log(event);
        }
    }
});

// 也可以用 JavaScript 直接调用方法
// vm.minusOne();
    
</script>
```



## 内联处理器方法 

除了直接绑定到一个方法，也可以用内联 JavaScript 语句： 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <button v-on:click="say('hi')">Say hi</button>
        <button v-on:click="say('what')">Say what</button>    
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {},
    methods: {
        say: function(message, event){
            alert(message);
        }
    }
});
</script>
```

有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 `$event` 把它传入方法： 

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id='app'>
        <button v-on:click="warn('Form cannot be submitted yet.', $event)">Submit</button>
    </div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {},
    methods: {
        warn: function (message, event) {
            // 现在可以访问原生事件对象
            if (event){
                event.preventDefault();
            }
            alert(message)
        }
    }
});
</script>
```



## 事件修饰符 

在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 

​	为了解决这个问题， Vue.js 为 `v-on` 提供了 **事件修饰符**。通过由点(.)表示的指令后缀来调用修饰符。 

- `.stop` 	
- `.prevent` 	
- `.capture` 	
- `.self` 
- `.once` (2.1.4 新增)
- `passive` (2.3.0 新增)

```html
<!-- 阻止单击事件冒泡 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联  -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件侦听器时使用时间捕获模式 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
<div v-on:click.self="doThat">...</div>
```

> 2.1.4 新增

```html
<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a>
```

不像其它只能对原生的 DOM 事件起作用的修饰符，`.once` 修饰符还能被用到自定义的[组件事件](https://cn.vuejs.org/v2/guide/components-custom-events.html)上。如果你还没有阅读关于组件的文档，现在大可不必担心。

> 2.3.0 新增

Vue 还对应 [`addEventListener` 中的 `passive` 选项](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters)提供了 `.passive` 修饰符。

```html
<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发, 而不会等待 `onScroll` 完成 -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```

这个 `.passive` 修饰符尤其能够提升移动端的性能。

不要把 `.passive` 和 `.prevent` 一起使用，因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，`.passive` 会告诉浏览器你*不*想阻止事件的默认行为。



## 按键修饰符 

在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符： 

```html
<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
<input v-on:keyup.13="submit">
```

>  `keyCode` 的事件用法[已经被废弃了](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode)并可能不会被最新的浏览器支持。 

记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 

```html
<!-- 同上 -->
<input v-on:keyup.enter="submit">
<!-- 缩写语法 -->
<input @keyup.enter="submit">
```

全部的按键别名： 

- enter	 
- tab	 
- delete (捕获 “删除” 和 “退格” 键)	 
- esc	 
- space	 
- up	 
- down	 
- left	 
- right 

> 可以通过全局 `config.keyCodes` 对象自定义按键修饰符别名： 
>
> ```javascript
> // 可以使用 v-on:keyup.f1
> Vue.config.keyCodes.f1 = 112
> ```

你可以直接将 [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。

```html
<input v-on:keyup.page-down="onPageDown">
```

在上述示例中，处理函数只会在 `$event.key` 等于 `PageDown` 时被调用。



## 系统修饰键

> 2.1.0 新增

可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。

- `.ctrl`
- `.alt`
- `.shift`
- `.meta`

> 注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。 

```html
<!-- Alt + C -->
<input @keyup.alt.67="clear">

<!-- Ctrl + Click -->
<div @click.ctrl="doSomething">Do something</div>
```

> 请注意修饰键与常规按键不同，在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 `ctrl` 的情况下释放其它按键，才能触发 `keyup.ctrl`。而单单释放 `ctrl` 也不会触发事件。如果你想要这样的行为，请为 `ctrl` 换用 `keyCode`：`keyup.17`。 

### .exact  修饰符

> 2.5.0 新增

`.exact` 修饰符允许你控制由精确的系统修饰符组合触发的事件。

```
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button @click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button @click.exact="onClick">A</button>
```

### 鼠标按钮修饰符

> 2.2.0 新增

- `.left`
- `.right`
- `.middle`

这些修饰符会限制处理函数仅响应特定的鼠标按钮。

# 条件渲染

## v-if , v-else 

> - `v-else` 元素必须紧跟在 `v-if` 或 `v-show` 元素的后面——否则它不能被识别。 
>
> -  **不推荐**同时使用 `v-if` 和 `v-for`。请查阅[风格指南](https://cn.vuejs.org/v2/style-guide/#避免-v-if-和-v-for-用在一起-必要)以获取更多信息。 

```HTML
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id="app">
        <p v-if="is_show">v-if条件渲染, 动态控制视图 显示 与 隐藏</p>
        <input type="button" value="显示出文字" v-on:click="is_show=true">
        <input type="button" value="控制显示与隐藏" @click="fnExchange">
    </div>
    <script>
        new Vue({
            el: '#app',
            data: {
                is_show: false,
            },
            methods: {
                fnExchange: function(){
                    if (this.is_show==true){
                        this.is_show = false;
                    }
                    else{
                        this.is_show = true;
                    }
                }
            }
        })
    </script>
</body>
```

## template v-if 

因为 `v-if` 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 ` 元素当做包装元素，并在上面使用 `v-if`，最终的渲染结果不会包含它。 

```HTML
<template v-if="ok">
    <h1>Title</h1>
    <p>Paragraph 1</p>
    <p>Paragraph 2</p>
</template>
```

## v-else-if

> 2.1.0 新增

```html
<div v-if="type === 'A'">A</div>
<div v-else-if="type === 'B'">B</div>
<div v-else-if="type === 'C'">C</div>
<div v-else>Not A/B/C</div>
```

类似于 `v-else`，`v-else-if` 也必须紧跟在带 `v-if` 或者 `v-else-if` 的元素之后。

## 用 key 管理可复用的元素

Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：

```html
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
<div id="app">
    <template v-if="loginType === 'username'">
        <label>Username</label>
        <input placeholder="Enter your username">
    </template>
    <template v-else>
        <label>Email</label>
        <input placeholder="Enter your email address">
    </template>
    <button v-on:click='chLoginType'>切换登录方式</button>
</div>
</body>
</html>
<script>
var vm = new Vue({
    el: '#app',
    data: {
        loginType: 'username',
    },
    methods: {
        chLoginType: function(){
            this.loginType = this.loginType === 'username' ? 'email' : 'username';
        }
    }
})
</script>
```

那么在上面的代码中切换 `loginType` 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，` <input> ` 不会被替换掉——仅仅是替换了它的 `placeholder`。

这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达 **“这两个元素是完全独立的，不要复用它们”** 。只需添加一个具有唯一值的 `key` 属性即可：

```html
<div id="app">
    <template v-if="loginType === 'username'">
        <label>Username</label>
        <input placeholder="Enter your username" key="username-input">
    </template>
    <template v-else>
        <label>Email</label>
        <input placeholder="Enter your email address" key="email-input">
    </template>
    <button v-on:click='chLoginType'>切换登录方式</button>
</div>
```

现在，每次切换时，输入框都将被重新渲染。

> 注意，` <label> ` 元素仍然会被高效地复用，因为它们没有添加 `key` 属性。





## v-show 

类似 v-if,  根据条件展示元素

> **v-if vs. v-show** 
>
> `v-if` 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。 
>
> `v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。 
>
> ​	相比之下， `v-show` 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。 
>
> ​	一般来说， `v-if` 有更高的切换消耗而 `v-show` 有更高的初始渲染消耗。因此，如果需要频繁切换使用 `v-show` 较好，如果在运行时条件不大可能改变则使用 `v-if` 较好。 
>
> ```
> v-show 不支持 <template> 元素，也不支持 v-else。
> v-show 只做元素样式的显示和隐藏，元素一直是存在的.
> v-show 隐藏元素时是加了一句 style="display: none;", v-if隐藏元素时是把元素替换成了 注释 <!-- -->
> ```

```html
<div id='app'>
    <div v-show="Math.random() > 0.5">it's right!</div>
    <!-- v-show 不能接 v-else -->
    <!-- <div v-else>it's wrong!</div> -->
</div>
```





# mixins 混入

混入：用于减少代码污染、减少代码量、实现代码重用

```javascript
// 额外临时加入时，用于显示日志
var addLog={
    updated:function(){
        console.log("数据放生变化,变化成"+this.count+".");
    }
}

// 实例化vue
var app = new Vue({
    // 挂载实例
    el:'#app',
    // 页面数据初始化，字符，对象、数组
    data:{
        count: 100
    },
    // 混入
    mixins: [addLog]
})
```

# extends 扩展

扩展：对构造器进行扩展

```javascript
// 扩展
var extendObj ={
    created: function(){
        console.log("我是被扩展出来的");
    }
}

// 实例化vue
var app = new Vue({
    // 挂载实例
    el:'#app',
    // 页面数据初始化，字符，对象、数组
    data:{
    },
    // 扩展
    extends: extendObj
})
```



# ==== More

# 实例生命周期

> 生命周期钩子 = 生命周期函数 = 生命周期事件

​	每个Vue实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新 DOM 等.

​	同时在这个过程中会自动运行一些叫做生命周期钩子的函数.

​	可以使用这些函数，在实例的不同阶段加上需要的代码，实现特定的功能.

| 周期          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| beforeCreate  | 在实例初始化之后，数据观测和事件配置之前被调用               |
| created       | 在实例创建完成后被立即调用，完成数据观测，属性和方法的运算，初始化事件，$el属性未见 |
| beforeMount   | 在挂载开始之前被调用：相关的 render 函数首次被调用，只在虚拟DOM生成HTML |
| mounted       | 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互 |
| beforeUpdate  | 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程 |
| updated       | 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用 |
| activated     | keep-alive 组件激活时调用                                    |
| deactivated   | keep-alive 组件停用时调用                                    |
| beforeDestroy | 在实例销毁之前调用。实例仍然完全可用                         |
| destroyed     | 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用 |



```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vue入门之Helloworld</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id="app">
        {{message}}
    </div>

<script type="text/javascript">
var app=new Vue({
    el:'#app',
    data:{
        message:'hello Vue!'
    },
    beforeCreate: function () {
        console.group('beforeCreate 创建前状态===============》');
        console.log("%c%s", "color:red" , "el      : " + this.$el); //undefined
        console.log("%c%s", "color:red","data    : " + this.$data); //undefined 
        console.log("%c%s", "color:red","message : " + this.message)  
    },
    created: function () {
        console.group('created 创建完毕状态===============》');
        console.log("%c%s", "color:red","el      : " + this.$el); //undefined
        console.log("%c%s", "color:red","data    : " + this.$data); //已被初始化 
        console.log("%c%s", "color:red","message : " + this.message); //已被初始化
    },
    beforeMount: function () {
        console.group('beforeMount 挂载前状态===============》');
        console.log("%c%s", "color:red","el      : " + (this.$el)); //已被初始化
        console.log(this.$el);
        console.log("%c%s", "color:red","data    : " + this.$data); //已被初始化  
        console.log("%c%s", "color:red","message : " + this.message); //已被初始化  
    },
    mounted: function () {
        console.group('mounted 挂载结束状态===============》');
        console.log("%c%s", "color:red","el      : " + this.$el); //已被初始化
        console.log(this.$el);     
        console.log("%c%s", "color:red","data    : " + this.$data); //已被初始化
        console.log("%c%s", "color:red","message : " + this.message); //已被初始化 
    },
    beforeUpdate: function () {
        console.group('beforeUpdate 更新前状态===============》');
        console.log("%c%s", "color:red","el      : " + this.$el);
        console.log(this.$el);    
        console.log("%c%s", "color:red","data    : " + this.$data); 
        console.log("%c%s", "color:red","message : " + this.message); 
    },
    updated: function () {
        console.group('updated 更新完成状态===============》');
        console.log("%c%s", "color:red","el      : " + this.$el);
        console.log(this.$el); 
        console.log("%c%s", "color:red","data    : " + this.$data); 
        console.log("%c%s", "color:red","message : " + this.message); 
    },
    beforeDestroy: function () {
        console.group('beforeDestroy 销毁前状态===============》');
        console.log("%c%s", "color:red","el      : " + this.$el);
        console.log(this.$el);     
        console.log("%c%s", "color:red","data    : " + this.$data); 
        console.log("%c%s", "color:red","message : " + this.message); 
    },
    destroyed: function () {
        console.group('destroyed 销毁完成状态===============》');
        console.log("%c%s", "color:red","el      : " + this.$el);
        console.log(this.$el);  
        console.log("%c%s", "color:red","data    : " + this.$data); 
        console.log("%c%s", "color:red","message : " + this.message)
    }
})
</script>
</body>
</html>
```



![测试实例生命周期](http://liangxinghua.com/uploads/image/20180709/1531106990.png)

# 数据交互 axios

vue.js 没有集成 ajax 功能

要使用 ajax 功能，可以使用 vue 官方推荐的 axios.js 库来做 ajax 的交互

axios 库的下载地址：[https://github.com/axios/axios/releases](https://github.com/axios/axios/releases)

> 类似的有 vue-resource:  https://github.com/pagekit/vue-resource



**axios完整写法**

```javascript
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
});
```

**执行get请求**

```javascript
// 为给定 ID 的 user 创建请求
// then是请求成功时的响应，catch是请求失败时的响应

axios.get('/user?ID=12345')
.then(function (response) {
  console.log(response);
})
.catch(function (error) {
  console.log(error);
});


// 可选的，上面的请求可以这样做
axios.get('/user', {
  params: {
    ID: 12345
  }
})
.then(function (response) {
  console.log(response);
})
.catch(function (error) {
  console.log(error);
});
```

**执行post请求**

```javascript
axios.post('/user', {
  firstName: 'Fred',
  lastName: 'Flintstone'
})
.then(function (response) {
  console.log(response);
})
.catch(function (error) {
  console.log(error);
});
```





# ==== 一些实例

## 跑马灯效果

1. HTML结构：

```html
<div id="app">
    <p>{{info}}</p>
    <input type="button" value="开启" v-on:click="go">
    <input type="button" value="停止" v-on:click="stop">
</div>
```

2. Vue实例：

```javascript
	// 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        info: '猥琐发育，别浪~！',
        intervalId: null
      },
      
      methods: {
        go() {
          // 如果当前有定时器在运行，则直接return
          if (this.intervalId != null) {
            return;
          }
          // 开始定时器
          this.intervalId = setInterval(() => {
            this.info = this.info.substring(1) + this.info.substring(0, 1);
          }, 500);
        },
        
        stop() {
          clearInterval(this.intervalId);
        }
      }
    });
```

## 简易计算器

1. HTML 代码结构

```html
  <div id="app">
    <input type="text" v-model="n1">
    <select v-model="opt">
      <option value="0">+</option>
      <option value="1">-</option>
      <option value="2">*</option>
      <option value="3">÷</option>
    </select>

    <input type="text" v-model="n2">
    <input type="button" value="=" v-on:click="getResult">
    <input type="text" v-model="result">
  </div>
```

2. Vue实例代码：

```javascript
	// 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        n1: 0,
        n2: 0,
        result: 0,
        opt: '0'
      },
      
      methods: {
        getResult() {
          switch (this.opt) {
            case '0':
              this.result = parseInt(this.n1) + parseInt(this.n2);
              break;
            case '1':
              this.result = parseInt(this.n1) - parseInt(this.n2);
              break;
            case '2':
              this.result = parseInt(this.n1) * parseInt(this.n2);
              break;
            case '3':
              this.result = parseInt(this.n1) / parseInt(this.n2);
              break;
          }
        }
      }
    });
```



